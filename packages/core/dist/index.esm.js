import{parseSync as e,printSync as t,print as n,parse as r,transformFileSync as a}from"@swc/core";export{parseSync as parse,parse as parseAsync}from"@swc/core";import{readFileSync as s,writeFileSync as i}from"fs";function p(t,n){return(r=e("("+t+")",n).body[0])&&"ExpressionStatement"===r.type&&"ParenthesisExpression"===r.expression.type?r.expression.expression:{type:"Invalid",span:{start:0,end:0,ctxt:0}};var r}function o(t,n){return e(`type A = ${t}`,Object.assign(Object.assign({},n),{syntax:"typescript"})).body[0].typeAnnotation}const l={type:"TsFunctionType",span:{start:199,end:221,ctxt:0},params:[{type:"RestElement",span:{start:203,end:215,ctxt:0},rest:{start:5691,end:5694,ctxt:0},argument:{type:"Identifier",span:{start:206,end:210,ctxt:4},value:"args",optional:!1},typeAnnotation:{type:"TsTypeAnnotation",span:{start:210,end:215,ctxt:0},typeAnnotation:{type:"TsArrayType",span:{start:212,end:215,ctxt:0},elemType:{type:"TsTypeReference",span:{start:212,end:213,ctxt:0},typeName:{type:"Identifier",span:{start:212,end:213,ctxt:4},value:"T",optional:!1}}}}}],typeParams:{type:"TsTypeParameterDeclaration",span:{start:199,end:202,ctxt:0},parameters:[{type:"TsTypeParameter",span:{start:200,end:201,ctxt:0},name:{type:"Identifier",span:{start:200,end:201,ctxt:4},value:"T",optional:!1},in:!1,out:!1}]},typeAnnotation:{type:"TsTypeAnnotation",span:{start:217,end:221,ctxt:0},typeAnnotation:{type:"TsTypeReference",span:{start:220,end:221,ctxt:0},typeName:{type:"Identifier",span:{start:220,end:221,ctxt:4},value:"T",optional:!1}}}},c={type:"TsFunctionType",span:{start:182,end:192,ctxt:0},params:[],typeParams:{type:"TsTypeParameterDeclaration",span:{start:182,end:185,ctxt:0},parameters:[{type:"TsTypeParameter",span:{start:183,end:184,ctxt:0},name:{type:"Identifier",span:{start:183,end:184,ctxt:4},value:"T",optional:!1},in:!1,out:!1}]},typeAnnotation:{type:"TsTypeAnnotation",span:{start:188,end:192,ctxt:0},typeAnnotation:{type:"TsTypeReference",span:{start:191,end:192,ctxt:0},typeName:{type:"Identifier",span:{start:191,end:192,ctxt:4},value:"T",optional:!1}}}},u={type:"TsKeywordType",span:{start:236,end:242,ctxt:0},kind:"string"};function d(e,n){const{code:r,map:a}=t({type:"Script",span:I,body:Array.isArray(e)?e:[e]},n);return{code:r.trim(),map:a}}async function y(e,t){const{code:r,map:a}=await n({type:"Script",span:I,body:Array.isArray(e)?e:[e]},t);return{code:r.trim(),map:a}}function f(e,t){const{code:n,map:r}=d({type:"ExpressionStatement",span:I,expression:e},t);return{code:n.replace(/\s*;\s*$/,""),map:r}}async function h(e,t){const{code:n,map:r}=await y({type:"ExpressionStatement",span:I,expression:e},t);return{code:n.replace(/\s*;\s*$/,""),map:r}}function m(e,t){const{code:n,map:r}=d({type:"TsTypeAliasDeclaration",span:I,declare:!1,id:{type:"Identifier",span:I,value:"__PrintType__",optional:!1},typeAnnotation:e},t);return{code:n.replace(/\s*type\s+__PrintType__\s*=\s*/,"").replace(/\s*;\s*$/,""),map:r}}async function x(e,t){const{code:n,map:r}=await y({type:"TsTypeAliasDeclaration",span:I,declare:!1,id:{type:"Identifier",span:I,value:"__PrintType__",optional:!1},typeAnnotation:e},t);return{code:n.replace(/\s*type\s+__PrintType__\s*=\s*/,"").replace(/\s*;\s*$/,""),map:r}}var v=H({enter(e){const t=this.get("scopeVars",[[]]);function n(e,n=undefined){var r,a;if("Identifier"===e.type)null===(r=t[t.length-1])||void 0===r||r.push({name:e.value,value:n,marker:e.marker});else{if("PrivateName"!==e.type)throw new Error(`Unhandled type ${e.type}!`);null===(a=t[t.length-1])||void 0===a||a.push({name:e.id.value,value:n,marker:e.marker,private:!0})}}function r(e){for(const t of e.properties)"AssignmentPatternProperty"===t.type?n(t.key):"RestElement"===t.type&&n(t.argument)}function a(e){for(const t of e.elements)t&&("Identifier"===t.type?n(t):"RestElement"===t.type?n(t.argument):"ObjectPattern"===t.type?r(t):"ArrayPattern"===t.type&&a(t))}function s(e){t.push([]);for(const t of e)switch(t.type){case"Identifier":n(t);break;case"RestElement":n(t.argument);break;case"AssignmentPattern":"Identifier"===(s=t).left.type?n(s.left,s.right):"ArrayPattern"===s.left.type?a(s.left):"ObjectPattern"===s.left.type&&r(s.left)}var s}if("FunctionDeclaration"===e.type)n(e.identifier,e),s(e.params.map((e=>e.pat)));else if("FunctionExpression"===e.type)s(e.params.map((e=>e.pat)));else if("ArrowFunctionExpression"===e.type)s(e.params);else if("ClassDeclaration"===e.type)n(e.identifier,e);else if("ClassMethod"===e.type)n(e.key),s(e.function.params.map((e=>e.pat)));else if("PrivateMethod"===e.type)n(e.key.id),s(e.function.params.map((e=>e.pat)));else if("VariableDeclaration"===e.type)for(const i of e.declarations)"Identifier"===i.id.type?n(i.id,i.init):"ArrayPattern"===i.id.type?a(i.id):"ObjectPattern"===i.id.type&&r(i.id);else if("CatchClause"===e.type){t.push([]);const s=e.param;s&&("Identifier"===s.type?n(s):"ArrayPattern"===s.type?a(s):"ObjectPattern"===s.type&&r(s))}else if("ImportDeclaration"===e.type)for(const i of e.specifiers)n(i.local)},leave(e){(["FunctionDeclaration","FunctionExpression","ArrowFunctionExpression","ClassDeclaration","ClassMethod","ClassPrivateMethod"].includes(e.type)||"CatchClause"===e.type)&&this.get("scopeVars",[[]]).pop()}});class g{constructor({enter:t,leave:n},r,a=!1){this.node={type:"Invalid",span:I},this.data={},this.imports=[],this.exports=[],this.prepends=[],this.appends=[],this.globalDts=[],this.moduleDts=[],this.references=[],this.prependDts=[],this.appendDts=[],this.importHashes={},this.exportHashes={},this.enters=[],this.leaves=[],this.enableTracker=!1,this.spanOffset=0,this.set=(e,t)=>{this.data[e]=t},this.get=(e,t)=>(e in this.data||(this.data[e]=t),this.data[e]||t),this.import=(e,t,n=!1)=>{let r;const a=(e,t)=>{this.imports.push({type:"ImportDeclaration",specifiers:e,source:{type:"StringLiteral",value:t,span:{start:0,end:0,ctxt:0}},typeOnly:!1,span:{start:0,end:0,ctxt:0}}),this.importHashes[r]=!0};if(null==t&&"string"==typeof e)return r=A({pkg:e}),void(r in this.importHashes||a([],e));for(const s of"string"==typeof e?[e]:e)r=A({s:s,source:t,isDefault:n}),r in this.importHashes||a([V(s,n)],t)},this.export=(e,t,n=!1)=>{let r;for(const a of"string"==typeof e?[e]:e)r=A({s:a,source:t,isNamespace:n}),r in this.exportHashes||(this.exports.push({type:"ExportNamedDeclaration",specifiers:[B(a,n)],source:null==t?void 0:{type:"StringLiteral",value:t,span:{start:0,end:0,ctxt:0}},typeOnly:!1,span:{start:0,end:0,ctxt:0}}),this.exportHashes[r]=!0)},this.prepend=e=>this.prepends.push(...e),this.append=e=>this.appends.push(...e),this.addPlugin=e=>{const{enter:t,leave:n}=O(e);t&&this.enters.push(t),n&&this.leaves.push(n)},this.declareModule=(e,t)=>this.moduleDts.push({type:"TsModuleDeclaration",span:{start:312,end:341,ctxt:0},declare:!0,global:!1,id:{type:"StringLiteral",span:{start:327,end:334,ctxt:0},value:e},body:{type:"TsModuleBlock",span:{start:335,end:341,ctxt:0},body:Array.isArray(t)?t:[t]}}),this.declareGlobal=e=>Array.isArray(e)?this.globalDts.push(...e):this.globalDts.push(e),this.declareGlobalConst=(e,t)=>this.declareGlobal(R(e,"string"==typeof t?o(t):t)),this.declareReference=({types:e,path:t})=>this.references.push({types:e,path:t}),this.declarePrepend=e=>this.prependDts.push(...e),this.declareAppend=e=>this.appendDts.push(...e),this.defaultContext={span:()=>{const e=this.node.span.start,t=this.node.span.end;return[e>this.spanOffset?e-this.spanOffset-1:0,t>this.spanOffset?t-this.spanOffset-1:0]},set:this.set,get:this.get,track:this.track,import:this.import,export:this.export,prepend:this.prepend,append:this.append,parseExpr:p,parseType:o,parse:(t,n)=>e(t,n).body,printExpr:e=>f(e).code,printType:e=>m(e).code,addPlugin:this.addPlugin,startTracking:()=>this.enableTracker=!0,stopTracking:()=>this.enableTracker=!1,declareAppend:this.declareAppend,declareGlobal:this.declareGlobal,declareModule:this.declareModule,declarePrepend:this.declarePrepend,declareReference:this.declareReference,declareGlobalConst:this.declareGlobalConst},t&&this.enters.push(t),n&&this.leaves.push(n),this.src=r,this.enableTracker=a}walkSingle(e,t,n,r){let a,s,i,p=0;this.node=e;const o=Object.assign(Object.assign({src:this.src},this.defaultContext),{skip:()=>{s=!0},print:t=>d(t||e).code,remove:()=>{t&&n&&(null!=r?t[n].splice(r,1):delete t[n]),i=!0},replace:e=>{t&&n&&(null!=r?Array.isArray(e)?(t[n].splice(r,1,...e),p=e.length-1):t[n][r]=e:t[n]=e,a=e)}});if(this.enableTracker&&v.enter.apply(o,[e,t,n,r]),this.enters.forEach((a=>a.apply(o,[e,t,n,r]))),Array.isArray(a))this.walkMany(a,t);else if(!s&&!i)for(const[l,c]of Object.entries(a||e))c&&(Array.isArray(c)?this.walkMany(c,e,l):c.type&&this.walkSingle(c,e,l));return this.leaves.forEach((a=>a.apply(o,[e,t,n,r]))),this.enableTracker&&v.leave.apply(o,[e,t,n,r]),p}walkMany(e,t,n){let r=0;for(let a=0;a<e.length;a++)r>0?r-=1:r=this.walkSingle(e[a],t,n,a)}walk(e,t=0){if(this.spanOffset=t,Array.isArray(e)?this.walkMany(e):e.type&&this.walkSingle(e),!Array.isArray(e)&&("Module"===e.type||"Script"===e.type)){const t=[],n=[],r=[];for(const a of e.body)["ImportDeclaration"].includes(a.type)?t.push(a):["ExportDeclaration","ExportNamedDeclaration","ExportDefaultDeclaration","ExportAllDeclaration"].includes(a.type)?n.push(a):r.push(a);e.body=[...t,...this.imports,...this.prepends,...r,...this.appends,...n,...this.exports]}return e}emit(){const e=[];let t;for(const r of this.references)t="/// <reference ",r.types&&(t+=`types="${r.types}"`),r.path&&(t+=`path="${r.path}"`),t+=" />\n",e.push(t);const n=this.globalDts.length>0?{type:"TsModuleDeclaration",span:{start:144,end:164,ctxt:0},declare:!0,global:!0,id:{type:"Identifier",span:{start:152,end:158,ctxt:1},value:"global",optional:!1},body:{type:"TsModuleBlock",span:{start:159,end:164,ctxt:0},body:this.globalDts}}:void 0;return(e.length>0?e.join(""):"")+d([...this.prependDts,...n?[n]:[],...this.moduleDts,...this.appendDts]).code.replace(/declare module global/g,"declare global")+"\nexport {}\n"}track(e){let t;const n=this.get("scopeVars",[[]]);for(let r=n.length-1;r>=0;r--){t=n[r];for(let n=t.length-1;n>=0;n--)if(t[n].name===e)return t[n]}}}function b(e,t){return new g(t).walk(e)}function E(e){return!(!e||!e.__macro_plugin__)}function T(e){return!(!e||!e.__macro_proxy__)}function w(e){let t=5381,n=(e=e.replace(/\r/g,"")).length;for(;n--;)t=(t<<5)-t^e.charCodeAt(n);return(t>>>0).toString(36)}function S(){return e("").span.end}function A(e){return w(JSON.stringify(e))}function k(e){return"[object RegExp]"===Object.prototype.toString.call(e)}function _(e){return e&&"object"==typeof e&&"type"in e}const $=()=>{},I={start:0,end:0,ctxt:0};function L(e,t){return t.marker=e,t}function M(e){return delete e.marker,e}function D(e){return new Function(`return (${e})`)()}function j(e){return D(f(e).code)}function P(e){if(void 0===e)return{type:"Identifier",span:{start:0,end:0,ctxt:2},value:"undefined",optional:!1};if(e&&"object"==typeof e){if(k(e))return this.parseExpr(e.toString());if("span"in e&&"type"in e)return e}return this.parseExpr("function"==typeof e?e.toString():JSON.stringify(e))}function C(e,t,n,r=!1){if(r)throw new Error("optional is not supported.");const a="object"==typeof e?e:p(e.toString()),s={};a.params.forEach(((e,n)=>{const r="ArrowFunctionExpression"===a.type?e:e.pat;"Identifier"===r.type?s[r.value]=t[n]?{value:t[n]}:{}:"AssignmentPattern"===r.type&&"Identifier"===r.left.type&&(s[r.left.value]={value:t[n]||r.right})}));let i={type:"Invalid",span:{start:0,end:0,ctxt:0}};return a.body&&(b(a.body,{enter(e){if("Identifier"===e.type&&e.value in s){const t=s[e.value].value;t&&this.replace(t)}},leave(e){"ReturnStatement"===e.type&&e.argument&&(i=e.argument)}}),"BlockStatement"!==a.body.type&&(i=a.body)),i}function O(e){return Array.isArray(e)||(e=[e]),{enter(t,n,r,a){let s,i;const p=e=>{s=e.apply(this,[t,n,r,a]),s&&this.replace(s)};for(const o of e)"function"!=typeof o||T(o)?(o.enter&&p(o.enter),t.type in o&&(i=o[t.type],"function"==typeof i?p(i):"object"==typeof i&&i.enter&&p(i.enter))):p(o)},leave(t,n,r,a){let s,i;const p=e=>{s=e.apply(this,[t,n,r,a]),s&&this.replace(s)};for(const o of e)"object"==typeof o&&(o.leave&&p(o.leave),t.type in o&&(i=o[t.type],"object"==typeof i&&i.leave&&p(i.leave)))}}}function R(e,t){return{type:"VariableDeclaration",span:{start:163,end:242,ctxt:0},kind:"const",declare:!1,declarations:[{type:"VariableDeclarator",span:{start:169,end:242,ctxt:0},id:{type:"Identifier",span:{start:169,end:172,ctxt:3},value:e,optional:!1,typeAnnotation:{type:"TsTypeAnnotation",span:{start:172,end:242,ctxt:0},typeAnnotation:t}},definite:!1}]}}function F(e,t,n="const"){return{type:"VariableDeclaration",span:{start:19,end:73,ctxt:0},kind:n,declare:!1,declarations:[{type:"VariableDeclarator",span:{start:23,end:73,ctxt:0},id:{type:"Identifier",span:{start:23,end:29,ctxt:2},value:t,optional:!1,typeAnnotation:{type:"TsTypeAnnotation",span:{start:29,end:73,ctxt:0},typeAnnotation:{type:"TsTypeQuery",span:{start:31,end:73,ctxt:0},exprName:{type:"TsImportType",span:{start:38,end:73,ctxt:0},argument:{type:"StringLiteral",span:{start:45,end:65,ctxt:0},value:e},qualifier:{type:"Identifier",span:{start:67,end:73,ctxt:2},value:t,optional:!1}}}}},definite:!1}]}}function N(e){return{type:"TsTypeReference",span:{start:199,end:205,ctxt:0},typeName:{type:"Identifier",span:{start:199,end:205,ctxt:2},value:e,optional:!1}}}function G(e){let t=typeof e;return"function"===t?l:"symbol"===t?N("Symbol"):"object"===t&&k(e)?N("RegExp"):(null===e&&(t="null"),{type:"TsKeywordType",span:{start:199,end:205,ctxt:0},kind:t})}function V(e,t=!1){const n={type:"Identifier",value:e,span:{start:0,end:0,ctxt:1},optional:!1};return t?{type:"ImportDefaultSpecifier",local:n,span:{start:0,end:0,ctxt:0}}:{type:"ImportSpecifier",local:n,span:{start:0,end:0,ctxt:0},isTypeOnly:!1}}function B(e,t=!1){const n={type:"Identifier",value:e,span:{start:0,end:0,ctxt:1},optional:!1};return t?{type:"ExportNamespaceSpecifier",name:n,span:{start:0,end:0,ctxt:0}}:{type:"ExportSpecifier",orig:n,span:{start:0,end:0,ctxt:0},isTypeOnly:!1}}function J(e){return e}function H(e){return Reflect.set(e,"__macro_plugin__",!0),e}function K(e){return new Proxy(e,{get:(e,t)=>"proxy"===t?t=>new Proxy(t,{ownKeys:t=>[...Reflect.ownKeys(e),...Reflect.ownKeys(t)],has:(t,n)=>Reflect.has(e,n)||Reflect.has(t,n),get:(t,n)=>"__macro_proxy__"===n||Reflect.get(e,n)||Reflect.get(t,n)}):"__macro_plugin__"===t||Reflect.get(e,t)})}function U(e,t,n){return H("string"==typeof e?{Module(){this.declareGlobalConst(e,n||G(t))},Identifier(n){n.value!==e||this.track(e)||(this.replace(P.apply(this,[t])),this.skip())}}:{Module(){let n;for(const[r,a]of Object.entries(e))t&&Object.keys(t).includes(r)?(n=t[r],this.declareGlobalConst(r,n)):this.declareGlobalConst(r,G(a))},Identifier(t){t.value in e&&!this.track(t.value)&&(this.replace(P.apply(this,[e[t.value]])),this.skip())}})}function W(e,t,n=l){return K("object"==typeof t?{Module(){this.declareGlobalConst(e,n)},CallExpression:{enter(n){var r;if(t.enter&&"Identifier"===n.callee.type&&n.callee.value===e&&!this.track(n.callee.value))return t.enter.apply(this,[n.arguments.map((e=>e.expression)),null===(r=n.typeArguments)||void 0===r?void 0:r.params,n.callee.optional])},leave(n){var r;if(t.leave&&"Identifier"===n.callee.type&&n.callee.value===e&&!this.track(n.callee.value))return t.leave.apply(this,[n.arguments.map((e=>e.expression)),null===(r=n.typeArguments)||void 0===r?void 0:r.params,n.callee.optional])}}}:{Module(){this.declareGlobalConst(e,n)},CallExpression(n){var r;if("Identifier"===n.callee.type&&n.callee.value===e&&!this.track(n.callee.value)){const e=n.arguments.map((e=>e.expression)),a=null===(r=n.typeArguments)||void 0===r?void 0:r.params;return t.toString().startsWith("function")?t.apply(this,[e,a,n.callee.optional]):C(t,e,0,n.callee.optional)}}})}function q(e,t,n=c){return H("object"==typeof t?{Module(){this.declareGlobalConst(e,n)},CallExpression:{enter(n){var r;if(t.enter&&"Identifier"===n.callee.type&&n.callee.value===e&&!this.track(n.callee.value)){if(n.arguments.length>0)throw new Error("TypeMacro doesn't support call with args.");return t.enter.apply(this,[null===(r=n.typeArguments)||void 0===r?void 0:r.params,n.callee.optional])}},leave(n){var r;if(t.leave&&"Identifier"===n.callee.type&&n.callee.value===e&&!this.track(n.callee.value)){if(n.arguments.length>0)throw new Error("TypeMacro doesn't support call with args.");return t.leave.apply(this,[null===(r=n.typeArguments)||void 0===r?void 0:r.params,n.callee.optional])}}}}:{Module(){this.declareGlobalConst(e,n)},CallExpression(n){var r;if("Identifier"===n.callee.type&&n.callee.value===e&&!this.track(n.callee.value)){if(n.arguments.length>0)throw new Error("TypeMacro doesn't support call with args.");const e=null===(r=n.typeArguments)||void 0===r?void 0:r.params;return t.apply(this,[e,n.callee.optional])}}})}function Q(e,t,n=u){return H({Module(){this.declareGlobalConst(e,{type:"TsFunctionType",span:{start:174,end:242,ctxt:0},params:[{type:"Identifier",span:{start:175,end:204,ctxt:2},value:"strings",optional:!1,typeAnnotation:{type:"TsTypeAnnotation",span:{start:182,end:204,ctxt:0},typeAnnotation:{type:"TsTypeReference",span:{start:184,end:204,ctxt:0},typeName:{type:"Identifier",span:{start:184,end:204,ctxt:2},value:"TemplateStringsArray",optional:!1}}}},{type:"RestElement",span:{start:206,end:231,ctxt:0},rest:{start:207,end:210,ctxt:0},argument:{type:"Identifier",span:{start:209,end:220,ctxt:2},value:"expressions",optional:!1},typeAnnotation:{type:"TsTypeAnnotation",span:{start:220,end:231,ctxt:0},typeAnnotation:{type:"TsArrayType",span:{start:222,end:231,ctxt:0},elemType:{type:"TsKeywordType",span:{start:222,end:229,ctxt:0},kind:"unknown"}}}}],typeAnnotation:{type:"TsTypeAnnotation",span:{start:233,end:242,ctxt:0},typeAnnotation:"string"==typeof n?this.parseType(n):n}})},TaggedTemplateExpression:{enter(n){var r;if("Identifier"===n.tag.type&&n.tag.value===e)return null===(r="object"==typeof t?t.enter:t)||void 0===r?void 0:r.apply(this,[n.template.quasis.map((e=>e.raw)),...n.template.expressions])},leave(e){if("object"==typeof t&&t.leave&&"Identifier"===e.tag.type)return t.leave.apply(this,[e.template.quasis.map((e=>e.raw)),...e.template.expressions])}}})}function z(e,t){return H({LabeledStatement:{enter(n,r,a,s){var i;if(n.label.value===e)return null===(i="object"==typeof t?t.enter:t)||void 0===i?void 0:i.apply(this,[n.body,r,a,s])},leave(n,r,a,s){var i;if(n.label.value===e&&"object"==typeof t)return null===(i=t.leave)||void 0===i?void 0:i.apply(this,[n.body,r,a,s])}}})}const X=(e,t,n,r=!1)=>z(e,(function(e){if(this.import(t,n),"BlockStatement"===e.type)return{type:"ExpressionStatement",expression:{type:"CallExpression",callee:{type:"Identifier",value:t,span:{start:0,end:0,ctxt:0}},arguments:[{expression:{type:"ArrowFunctionExpression",generator:!1,async:!1,params:[],body:e,span:{start:0,end:0,ctxt:0}}}],span:{start:0,end:0,ctxt:0}},span:{start:0,end:0,ctxt:0}};if("ExpressionStatement"===e.type&&"ArrowFunctionExpression"===e.expression.type)return{type:"ExpressionStatement",expression:{type:"CallExpression",callee:{type:"Identifier",value:t,span:{start:0,end:0,ctxt:0}},arguments:[{expression:e.expression}],span:{start:0,end:0,ctxt:0}},span:{start:0,end:0,ctxt:0}};if(r&&"ExpressionStatement"===e.type&&"ArrayExpression"===e.expression.type)return{type:"ExpressionStatement",expression:{type:"CallExpression",callee:{type:"Identifier",value:t,span:{start:0,end:0,ctxt:0}},arguments:e.expression.elements,span:{start:0,end:0,ctxt:0}},span:{start:0,end:0,ctxt:0}};throw new Error("this macro only accept a ArrowFunction or BlockStatement"+(r?" or an ArrayExpression":""))})),Y=(e,t,n)=>H({LabeledStatement(r){if(r.label.value===e){if("ExpressionStatement"===r.body.type)return this.import(t,n),r.body.expression={type:"CallExpression",span:{start:109,end:119,ctxt:0},callee:{type:"Identifier",span:{start:109,end:112,ctxt:1},value:t,optional:!1},arguments:[{expression:r.body.expression}]},r.body;throw new Error("this macro only accept an Expression")}}});function Z(e,t,n=0){return r=>{var a;const s=new g(O(e.macros||[]),t,!0);if(r=s.walk(r,n),e.emitDts){const t=s.emit();null===(a=e.onEmitDts)||void 0===a||a.call(e,t),r.dts=t}return r}}function ee(e,t,n,r=0){return Z(t,n,r)(e)}function te(n,r){var a;const s=S(),i=ee(e(n,null===(a=r.jsc)||void 0===a?void 0:a.parser),r,n,s),p=i.dts;return p&&delete i.dts,Object.assign(Object.assign({},t(i)),{ast:i,dts:p})}async function ne(e,t){var a;const s=S(),i=ee(await r(e,null===(a=t.jsc)||void 0===a?void 0:a.parser),t,e,s),p=await n(i),o=i.dts;return o&&delete i.dts,Object.assign(Object.assign({},p),{ast:i,dts:o})}var re=$,ae=e=>e,se=e=>e,ie=e=>e,pe=e=>e,oe=$;const le=H({Module(){this.declareGlobal(["$Macro","$LitMacro","$ExprMacro","$TypeMacro","$TmplMacro","$LabeledMacro"].map((e=>F("@macro-plugin/core",e,"var"))))},LabeledStatement:{enter(e){var t;if("macro"!==e.label.value)return;this.stopTracking();const n=this.get("ExprMacros",{}),r=this.get("LitMacros",{}),a=[],s="BlockStatement"===e.body.type?e.body.stmts:[e.body],i=(e,t)=>{if("Identifier"===e.type)a.push(U(e.value,t));else if("ArrayPattern"===e.type)e.elements.forEach(((e,n)=>{e&&i(e,t?{type:"MemberExpression",span:{start:342,end:348,ctxt:0},object:t,property:{type:"Computed",span:{start:345,end:348,ctxt:0},expression:{type:"NumericLiteral",span:{start:346,end:347,ctxt:0},value:n}}}:void 0)}));else{if("ObjectPattern"!==e.type)throw new Error("Unexpected macro type.");e.properties.forEach((n=>{if("AssignmentPatternProperty"===n.type&&null==n.value)i(n.key,t?{type:"MemberExpression",span:{start:342,end:353,ctxt:0},object:{type:"ParenthesisExpression",span:{start:342,end:353,ctxt:0},expression:t},property:{type:"Computed",span:{start:345,end:353,ctxt:0},expression:{type:"StringLiteral",span:{start:346,end:352,ctxt:0},value:n.key.value}}}:void 0);else{if("RestElement"!==n.type)throw new Error("Unexpected Object Pattrn type.");i(n.argument,t?{type:"ArrowFunctionExpression",span:{start:368,end:427,ctxt:0},params:[],body:{type:"BlockStatement",span:{start:374,end:427,ctxt:0},stmts:[{type:"VariableDeclaration",span:{start:380,end:409,ctxt:0},kind:"const",declare:!1,declarations:[{type:"VariableDeclarator",span:{start:386,end:409,ctxt:0},id:e,init:t,definite:!1}]},{type:"ReturnStatement",span:{start:414,end:423,ctxt:0},argument:n.argument}]},async:!1,generator:!1}:void 0)}}))}};for(const p of s)if("VariableDeclaration"===p.type&&"var"===p.kind)for(const e of p.declarations)if("Identifier"===e.id.type&&e.init)if(["FunctionExpression","ArrowFunctionExpression","FunctionDeclaration"].includes(e.init.type))n[e.id.value]=e.init;else if("CallExpression"===e.init.type&&"Identifier"===e.init.callee.type)switch(e.init.callee.value){case"$LitMacro":r[e.id.value]=e.init.arguments[0].expression;break;case"$ExprMacro":a.push(W(e.id.value,j(e.init.arguments[0].expression)));break;case"$TmplMacro":a.push(Q(e.id.value,j(e.init.arguments[0].expression)));break;case"$TypeMacro":a.push(q(e.id.value,j(e.init.arguments[0].expression)));break;case"$LabeledMacro":case"$Macro":throw new Error("VariableDeclaration is not expected for $Labeled and $Macro.");default:i(e.id,e.init)}else i(e.id,e.init);else i(e.id,e.init);else if("ExpressionStatement"===p.type&&"CallExpression"===p.expression.type&&"Identifier"===p.expression.callee.type)switch(p.expression.callee.value){case"$LabeledMacro":a.push(z("StringLiteral"===p.expression.arguments[0].expression.type?p.expression.arguments[0].expression.value:(null===(t=p.expression.typeArguments)||void 0===t?void 0:t.params[0]).literal.value,j(p.expression.arguments[1].expression)));break;case"$Macro":a.push(H(j(p.expression.arguments[0].expression)));break;case"$LitMacro":case"$ExprMacro":case"$TmplMacro":case"$TypeMacro":throw new Error("Expect VariableDeclaration for $Lit, $Expr, $Tmpl, $Type.")}this.replace({type:"EmptyStatement",span:{start:0,end:0,ctxt:0}}),this.addPlugin(a)},leave(e){"macro"===e.label.value&&this.startTracking()}},Identifier(e){const t=this.get("LitMacros",{});e.value in t&&(this.replace(t[e.value]),this.skip())},CallExpression(e){if("Identifier"===e.callee.type){const t=this.get("ExprMacros",{});if(e.callee.value in t)return C(t[e.callee.value],e.arguments.map((e=>e.expression)),e.typeArguments,e.callee.optional)}}});var ce=W("$Eval",(function(e){const t=e[0].type;if("StringLiteral"===t)return this.parseExpr(D(e[0].value));if("TemplateLiteral"===t){const t=e=>this.track(e);return b(e[0],{enter(e){if("Identifier"===e.type){const n=t(e.value);n&&n.value&&this.replace(n.value)}}}),this.parseExpr(D(D(this.printExpr(e[0]))))}return this.parseExpr("FunctionExpression"===t||"ArrowFunctionExpression"===t?D(`(${this.printExpr(e[0])})(${e.slice(1).map((e=>this.printExpr(e))).join(",")})`):j(e[0]).toString())}),"(<T>(expr: string) => T) & (<T>(expr: T) => T) & (<F extends (...args: any) => any>(expr: F, ...args: Parameters<F>) => ReturnType<F>)");const ue=e=>JSON.stringify(e).replace(/("(start|end|ctxt)":\s*)(\d+)/g,"$10");var de=W("$Ast",(function(e){return this.parseExpr(ue("StringLiteral"===e[0].type?this.parseExpr(e[0].value):e[0]))}),'<T>(expr: T) => import("@swc/core").Expression'),ye=W("$Env",(function(e,t){var n;if("StringLiteral"!==e[0].type)throw new Error("$Env macro only support StringLiteral as input.");const r=null!==(n=process.env[e[0].value])&&void 0!==n?n:"";if(t&&"TsKeywordType"===(null==t?void 0:t[0].type))switch(t[0].kind){case"boolean":return{type:"BooleanLiteral",value:!!r,span:I};case"number":return{type:"NumericLiteral",value:+r,span:I}}return{type:"StringLiteral",span:I,value:r}}),"<R = string>(key: string) => R"),fe=W("$Stringify",(function(e,t){return{type:"StringLiteral",span:I,value:t&&t.length>0?this.printType(t[0]):this.printExpr(e[0])}}),"((expr: any) => string) & (<T>() => string)"),he=W("$Span",(function(){const e=this.span();return{type:"ArrayExpression",span:I,elements:[{expression:{type:"NumericLiteral",span:I,value:e[0]}},{expression:{type:"NumericLiteral",span:I,value:e[1]}}]}}),"() => [number, number]"),me=W("$Line",(function(){var e;return{type:"NumericLiteral",span:I,value:(null===(e=this.src)||void 0===e?void 0:e.slice(0,this.span()[0]).split(/\r\n|\r|\n/).length)||1}}),"() => number"),xe=W("$Column",(function(){var e,t,n;return{type:"NumericLiteral",span:I,value:(null===(n=null===(t=null===(e=this.src)||void 0===e?void 0:e.slice(0,this.span()[0]))||void 0===t?void 0:t.match(/\n[^\n]*$/))||void 0===n?void 0:n[0].length)||1}}),"() => number"),ve=W("$ID",(function(){return{type:"StringLiteral",span:I,value:w(`${this.src}${this.span()}`)}}),"() => string");function ge(e){return{type:"CallExpression",span:I,callee:{type:"ParenthesisExpression",span:I,expression:{type:"ArrowFunctionExpression",span:I,params:[],body:{type:"BlockStatement",span:I,stmts:[{type:"ThrowStatement",span:I,argument:{type:"NewExpression",span:I,callee:{type:"Identifier",span:I,value:"Error",optional:!1},arguments:[{expression:{type:"StringLiteral",span:I,value:e}}]}}]},async:!1,generator:!1}},arguments:[]}}var be=W("$UnImplemented",(function(){return console.error("not implemented"),ge("not implemented")}),"() => never"),Ee=W("$Todo",(function(){console.warn("not yet implemented"),this.replace(ge("not yet implemented"))}),"() => never"),Te=W("$UnReachable",(function(){return ge("internal error: entered unreachable code")}),"() => never"),we=W("$Include",(function(t){var n,r;if("StringLiteral"!==(null===(n=t[0])||void 0===n?void 0:n.type))throw new Error("$Include only accept StringLiteral as input.");let s="commonjs";"StringLiteral"===(null===(r=t[1])||void 0===r?void 0:r.type)&&["es6","commonjs","umd","nodenext"].includes(t[1].value)&&(s=t[1].value);const i={parser:{syntax:"typescript"}},p=Z({macros:[],jsc:i});return{type:"CallExpression",span:I,callee:{type:"ParenthesisExpression",span:I,expression:{type:"ArrowFunctionExpression",span:I,params:[],body:{type:"BlockStatement",span:I,stmts:e(a(t[0].value,{jsc:i,plugin:p,module:{type:s}}).code).body},async:!1,generator:!1}},arguments:[]}}),"(path: string, target?: 'es6' | 'commonjs' | 'umd' | 'nodenext') => void"),Se=W("$IncludeStr",(function(e){var t;if("StringLiteral"!==(null===(t=e[0])||void 0===t?void 0:t.type))throw new Error("$IncludeStr only accept StringLiteral as input.");return{type:"StringLiteral",value:s(e[0].value).toString(),span:I}}),"(path: string) => string"),Ae=W("$IncludeJSON",(function(e){var t,n;if("StringLiteral"!==(null===(t=e[0])||void 0===t?void 0:t.type))throw new Error("$IncludeJSON only accept StringLiteral as input.");let r=s(e[0].value).toString();if("StringLiteral"===(null===(n=e[1])||void 0===n?void 0:n.type)){const t=JSON.parse(r)[e[1].value];r=JSON.stringify(t)}return this.parseExpr(r)}),"(<T extends Record<string, any>>(path: string) => T) & (<R = string>(path: string, key: string) => R)"),ke=W("$WriteFile",(function(e){var t,n;if("StringLiteral"!==(null===(t=e[0])||void 0===t?void 0:t.type))throw new Error("$WriteFile only accept StringLiteral as first parameter.");if("StringLiteral"!==(null===(n=e[1])||void 0===n?void 0:n.type))throw new Error("$WriteFile only accept StringLiteral as second parameter.");return i(e[0].value,e[1].value,{encoding:"utf-8"}),{type:"Identifier",value:"undefined",span:I}}),"(file: string, data: string) => void"),_e=W("$Concat",(function(e){let t="";const n='only literals (like `"foo"`, `42` and `3.14`) can be passed to `$Concat()`';for(const r of e)switch(r.type){case"StringLiteral":case"BooleanLiteral":case"NumericLiteral":case"BigIntLiteral":t+=r.value;break;case"NullLiteral":t+="null";break;case"Identifier":if("undefined"===r.value){t+=r.value;break}throw new Error(n);default:throw new Error(n)}return{type:"StringLiteral",value:t,span:I}}),"(...args: (string | null | undefined | boolean | number | bigint)[]) => string");const $e=(e,t)=>e.reduce(((e,n,r)=>{const a=e+n;return r<t.length?a+f(t[r]).code:a}),""),Ie=(e,t)=>e.reduce(((e,n,r)=>{const a=e+n;return r<t.length?a+t[r]:a}),"");function Le(e,t,n,r){if(e&&"object"==typeof e){const a=Object.keys(e);for(let s=0;s<a.length;s++){const i=a[s],p=e[i],o=t(i,p,e);if(null!=o&&n){n[r]=o;break}"object"==typeof p&&Le(p,t,e,i)}}return e}var Me=Q("$Expr",(function(e,...t){const n=t.map(((e,t)=>"_macro_marker_"+t+"_")),r=this.parseExpr(Ie(e,n),{syntax:"typescript",tsx:!0});Le(r,((e,r,a)=>{if("span"!==e){if("string"==typeof r){const e=n.findIndex((e=>e===r));if(-1!==e)return"__macro$$Start__"+this.printExpr(t[e])+"__macro$$End__"}}else a[e]=I}));const a=JSON.stringify(r,void 0,2).replace(/("__macro\$\$Start__)|(__macro\$\$End__")/g,"").replace(/\\"/g,'"');return this.parseExpr(a)}),'import("@swc/core").Expression'),De=Q("$Quote",(function(e,...t){const n=t.map(((e,t)=>"_macro_marker_"+t+"_")),r=this.parse(Ie(e,n),{syntax:"typescript",tsx:!0});Le(r,((e,r,a)=>{if("span"!==e){if("string"==typeof r){const e=n.findIndex((e=>e===r));if(-1!==e)return"__macro$$Start__"+this.printExpr(t[e])+"__macro$$End__"}}else a[e]=I}));const a=JSON.stringify(r,void 0,2).replace(/("__macro\$\$Start__)|(__macro\$\$End__")/g,"").replace(/\\"/g,'"');return this.parseExpr(a)}),'(import("@swc/core").Expression)[]');export{de as $Ast,xe as $Column,_e as $Concat,ye as $Env,ce as $Eval,Me as $Expr,se as $ExprMacro,ve as $ID,we as $Include,Ae as $IncludeJSON,Se as $IncludeStr,oe as $LabeledMacro,me as $Line,ae as $LitMacro,re as $Macro,De as $Quote,he as $Span,fe as $Stringify,pe as $TmplMacro,Ee as $Todo,ie as $TypeMacro,be as $UnImplemented,Te as $UnReachable,ke as $WriteFile,g as Walker,W as createExprMacro,X as createLabeledBlock,Y as createLabeledExpr,z as createLabeledMacro,P as createLit,U as createLitMacro,H as createMacro,K as createProxyMacro,Z as createSwcPlugin,Q as createTmplMacro,q as createTypeMacro,O as createWalkPlugin,J as defineConfig,j as evalAst,D as evalExpr,C as flatExpr,R as genConstType,B as genExportSpecifier,V as genImportSpecifier,N as genTsRef,F as genTypeImport,S as getSpanOffset,G as guessType,w as hash,A as hashMap,E as isMacroPlugin,T as isMacroProxy,_ as isNode,k as isRegExp,le as macro,L as markedNode,$ as noop,p as parseExpr,o as parseType,d as print,ue as printAst,y as printAsync,f as printExpr,h as printExprAsync,Ie as printRawTmpl,$e as printTmpl,m as printType,x as printTypeAsync,I as span,te as transform,ee as transformAst,ne as transformAsync,M as unMarkNode,b as walk};
